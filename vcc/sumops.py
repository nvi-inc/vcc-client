import re
import sys
import traceback
from pathlib import Path
from datetime import datetime, timedelta
from collections import defaultdict, namedtuple
from operator import itemgetter
import json

import tkinter as tk
from tkinter import ttk, messagebox, font

from vcc import settings, VCCError, json_decoder
from vcc.session import Session
from vcc.client import VCC
from vcc.ns import get_ddout_log
from vcc.xwidget import XEntry, XCombobox, XMenu, FakeEntry
from vcc.skd import SKD, VEX


def SumOps(ses_id):

    def print_info(stations, show_unknown=False):
        for station in stations:
            if records := issues.get(station):
                if records[0]['issue'] == 'ok':
                    print(f'{station:<7s} Ok.')
                else:
                    problems = {'Warm': defaultdict(list), 'Affected': defaultdict(list), 'Missed': defaultdict(list)}
                    for record in records:
                        problems[record['issue']][record['comment']].append(record)
                    for problem in problems.keys():
                        if problem:
                            for comment, items in problems[problem].items():
                                periods = [f'({info["start"]}--{info["end"]})' for info in items]
                                print(f'{station:<7s} {comment}. {problem} scans {" ".join(periods)}.')
                    #print()
            elif show_unknown:
                print(f'{station:<7s} No information.')

    with VCC() as vcc:
        if not vcc.is_available:
            print('Could not connect to VCC')
        elif not (rsp := vcc.get(f'/sessions/{ses_id}')):  # Get session information
            print(f'{ses_id} not found')
        else:
            session = Session(json_decoder(rsp.json()))
            print(f'SumOps report for {session.code} generated by VCC\n')
            if rsp := vcc.get(f'/sumops/{session.code}'):
                issues = defaultdict(list)
                for rec in sorted(json_decoder(rsp.json()), key=itemgetter('sta_id', 'start')):
                    issues[rec['sta_id'].capitalize()].append(rec)
                print_info(session.included, show_unknown=True)
                print_info(session.removed, show_unknown=False)


class Unsent:
    def __init__(self):
        self.index = -1
        self._put, self._delete = {}, {}
        self.path = Path(settings.Folders.scratch, 'schedend.unsent')
        if self.path.exists():
            with open(self.path, 'r') as f:
                data = json.load(f)
                self.index, self._put, self._delete = data['index'], data['put'], data['delete']

    def __del__(self):
        with open(Path(settings.Folders.scratch, 'schedend.unsent'), 'w+') as f:
            json.dump({'index': self.index, 'put': self._put, 'delete': self._delete})

    def put(self, index, record, ses_id, sta_id):
        if index is None:
            index, self.index = self.index, self.index - 1
            record['ses_id'], record['sta_id'] = ses_id, sta_id
        self._put[index] = record
        return index

    def delete(self, index, record):
        if index < 0:
            if index in self._put:
                self._put.pop(index)
            else:
                self._delete[index] = record
        return index

    def send(self, vcc):
        try:
            # Send all put records
            for index in list(self._put.keys()):
                record = self._put[index]
                if vcc.put(f'/sumops/{record["ses_id"]}/{record["sta_id"]}', data=record):
                    self._put.pop(index)
            # send all delete records
            for index in list(self._delete.keys()):
                record = self._put[index]
                if vcc.delete(f'/sumops/{record["ses_id"]}/{record["sta_id"]}/{index}'):
                    self._delete.pop(index)
        except VCCError as err:
            return

    def get(self, ses_id, sta_id):
        for index, record in self._put.items():
            if record['ses_id'] == ses_id and record['sta_id'] == sta_id and index not in self._delete:
                yield record


class ValidationError(Exception):
    def __init__(self, title, message):
        # Call the base class constructor with the parameters it needs
        super().__init__(message)
        # Keep title
        self.title = title


class Scans:
    is_utc = re.compile(r'[0-2][0-9]:[0-5][0-9]').match

    def __init__(self, group, ses_id, sta_id, schedule):
        self.ses_id, self.sta_id = ses_id.lower(), sta_id.lower()
        self.data, self.names = defaultdict(list), []
        if isinstance(schedule, SKD):
            self.extract(schedule)
            return

        path = None
        folder = getattr(settings.Folders, 'schedule', '.') if hasattr(settings, 'Folders') else '.'
        if schedule:
            path = path if (path := Path(schedule)).exists() else Path(folder, schedule)
        if not path or not path.exists():
            for name in [f'{self.ses_id}{ext}' for ext in [f'{self.sta_id}.snp', '.skd', '.vex']]:
                if (path := Path(folder, name)).exists():
                    break
            else:
                msg = "SNAP file" if group == 'NS' else 'SKD or VEX files'
                raise ValidationError('Scans', f'no {msg} for {self.ses_id}')

        self.path = path
        if not self.path.exists():
            raise ValidationError('Scans', f'{str(self.path)} does not exist')
        elif (ext := self.path.suffix) == '.snp':
            self.read_snap()
        elif ext in ['.skd', '.vex']:
            self.read_schedule(sta_id.capitalize(), ext)
        else:
            raise ValidationError('Scans', f'{self.path.name} is invalid file type')
        if self.is_empty():
            raise ValidationError('Scans', f'{self.path.name} has no information')

    def read_snap(self):
        with open(self.path) as snp:
            for line in snp.read().splitlines():
                if line.startswith('!'):
                    utc = datetime.strptime(line, '!%Y.%j.%H:%M:%S')
                elif line.startswith('scan_name'):
                    self.names.append(name := line[10:].split(',')[0])
                elif line.startswith('data_valid'):
                    self.data[name].append(utc)

    def extract(self, skd):
        sta_id = self.sta_id.capitalize()
        if sta_id not in skd.stations['codes']:
            messagebox.showerror(self.ses_id, f'{sta_id} not in schedule')
            sys.exit(1)

        for name, data in skd.stations['codes'][sta_id]['scans'].items():
            self.names.append(name)
            self.data[name] = [data['start'],
                               data['start'] + timedelta(seconds=data['station_codes'][sta_id]['duration'])]

    def read_schedule(self, sta_id, ext):
        cls = VEX if ext == '.vex' else SKD
        with cls(self.path) as skd:
            skd.read()
            self.extract(skd)

    def is_empty(self):
        return len(self.names) == 0

    def __getitem__(self, name):
        return name if name in self.names else {'start': self.names[0], 'end': self.names[-1]
                                                }.get(name, self.get_scan_from_time(name))

    def __len__(self):
        return len(self.names)

    def get_scan_from_time(self, hm):
        if not self.is_utc(hm):
            return None
        start, end = self.session.start, self.session.end
        if (t := datetime.strptime(f"{start.strftime('%Y.%j')}.{hm}", "%Y.%j.%H:%M")) < start:
            t = datetime.strptime(f"{end.strftime('%Y.%j')}.{hm}", "%Y.%j.%H:%M")
        if t > end:
            return None
        for name,  [_, end] in self.data.items():
            if t <= end:
                return name
        return self.names[-1]

    def slice(self, first, last):
        first, last = self[first], self[last]
        return self.names[self.names.index(first):self.names.index(last)+1]

    def nbr(self, first, last):
        first, last = self[first], self[last]
        if first is None or last is None:
            return ''
        return self.names.index(last) - self.names.index(first) + 1


class Info(ttk.LabelFrame):
    def __init__(self, parent, sta_id, session, scans):

        super().__init__(parent, text=f'{session.code}{sta_id}', padding=(0, 0, 0, 0))

        self.add_entry('Start', session.start.strftime('%Y.%j.%H:%M:%S'), 0)
        self.add_entry('End', session.end.strftime('%Y.%j.%H:%M:%S'), 2)
        self.add_entry('Number scans', str(len(scans)), 4, justify='right', width=6)
        self.pack(expand=tk.NO, fill=tk.BOTH)
        self.update()

    def add_entry(self, label, text, col, justify='left', width=None):
        ttk.Label(self, text=label, style="LLabel.TLabel").grid(row=0, column=col)
        entry_var = tk.StringVar(master=self, value=text)
        entry = tk.Entry(self, textvariable=entry_var, state=tk.DISABLED, justify=justify, width=width)
        entry.configure(disabledbackground="white", disabledforeground="black")
        entry.grid(row=0, column=col+1, padx=5, pady=5)


class Editor(ttk.LabelFrame):

    def __init__(self, parent, scans, state):

        self.ok, self.need_save = None, False
        self.scans = scans
        self.default_state = state

        super().__init__(parent, text="Record", padding=(0, 0, 5, 0))

        # Labels for all fields
        ttk.Label(self, text="Issue", style="LLabel.TLabel").grid(row=0, column=0, sticky="W")
        ttk.Label(self, text="Start", style="LLabel.TLabel").grid(row=0, column=2, sticky='W')
        ttk.Label(self, text="End", style="LLabel.TLabel").grid(row=0, column=4, sticky='W')
        ttk.Label(self, text="Number of scans", style="LLabel.TLabel").grid(row=0, column=6, sticky='W')
        ttk.Label(self, text="Comment", style="LLabel.TLabel").grid(row=1, column=0, sticky='W')

        issues = ['Missed', 'Affected', 'Warm']
        self.issue = XMenu(self, 'Select..', *issues, command=lambda *args: self.on_change('issue'),
                           style='Options.TMenubutton')
        self.issue.configure(width=len(max(issues, key=len)), state=self.default_state)
        self.issue.grid(row=0, column=1, sticky='w')

        # Begin and end combo box
        self.start = XCombobox(self, values=self.scans.names, postcommand=lambda *args: self.on_change('start'),
                               style='Scans.TCombobox')
        self.start.grid(row=0, column=3, padx=5, sticky='W')

        self.end = XCombobox(self, values=self.scans.names, postcommand=lambda *args: self.on_change('end'),
                             style='Scans.TCombobox')
        self.end.grid(row=0, column=5, sticky='W')
        self.nbr = FakeEntry(self, width=6, anchor='e')
        self.nbr.grid(row=0, column=7, padx=(0, 5), sticky='w')

        self.comment = XEntry(self, on_change=lambda *args: self.on_change('comment'))
        self.comment.grid(row=1, column=1, padx=0, pady=5, columnspan=8, sticky='we')

        self.action = ttk.Button(self, text="Add", style='TButton')
        self.action.grid(row=0, column=8, padx=(5, 0), sticky='E')
        self.columnconfigure(8, weight=1)
        self.pack(expand=tk.NO, fill=tk.BOTH)
        self.update()
        self.reset()

    def reset(self):
        self.issue.reset('Select...', state=self.default_state)
        for widget in [self.start, self.end, self.nbr, self.comment]:
            widget.reset()
        self.action.configure(text='Add', state='disabled')

    def validate_scan_name(self, text, extra):
        if text in extra or self.scans[text] is not None:
            return True
        return False

    def on_change(self, code):
        if self.action['text'] == 'Delete':
            self.action['text'] = 'Update'
        if code == 'issue':
            self.start.configure(state='normal')
        elif code == 'start':
            if self.validate_scan_name(self.start.get(), ['start']):
                self.end.reset(self.scans[self.start.get()], state='normal',
                               values=self.scans.slice(self.start.get(), 'end'))
            else:
                self.end.configure(state='disabled')
                self.comment.configure(state='disabled')
                self.action.configure(state='disabled')
        elif code == 'end':
            state = 'normal' if self.validate_scan_name(self.end.get(), ['end']) else 'disabled'
            self.nbr.reset(self.scans.nbr(self.start.get(), self.end.get()), 'normal')
            self.comment.configure(state=state)
            self.action.configure(state=state)

    @property
    def record(self):
        first, last = self.scans[self.start.get()], self.scans[self.end.get()]
        nbr = self.scans.nbr(first, last)
        return dict(issue=self.issue.get(), start=first, end=last, nbr=nbr, comment=self.comment.get())

    @record.setter
    def record(self, record):
        self.issue.reset(text=record['issue'], state='normal')
        self.start.reset(text=record['start'], state='normal')
        self.end.reset(text=record['end'], state='normal', values=self.scans.slice(record['start'], 'end'))
        self.nbr.set(self.scans.nbr(record['start'], record['end']))
        self.comment.reset(record['comment'], state='normal')
        self.action['text'] = 'Delete'

    def bind(self, fnc):
        self.action.bind('<Button-1>', lambda event: fnc(self.action['text']))


class Viewer(ttk.Frame):
    header = {'Issue': (100, tk.W, tk.NO), 'Start': (100, tk.CENTER, tk.NO), 'End': (100, tk.CENTER, tk.NO),
              'Number': (50, tk.CENTER, tk.NO), 'Comments': (500, tk.W, tk.YES)}

    def __init__(self, parent, records):
        width, height = sum([info[0] for info in self.header.values()]), 150
        self.records = records

        super().__init__(parent, height=height, width=width+20, padding=(0, 5, 0, 5))

        # Add a Treeview widget
        self.tree = ttk.Treeview(self, column=list(self.header.keys()), show='headings', height=5)
        self.tree.place(width=width, height=height)
        # Add a vertical scrollbar
        vsb = ttk.Scrollbar(self, orient="vertical", command=self.tree.yview)
        vsb.place(width=20, height=height)
        vsb.pack(side='right', fill='y')
        self.tree.configure(yscrollcommand=vsb.set)
        self.tree.tag_configure('cancelled', background="red")

        for col, (key, info) in enumerate(self.header.items(), 1):
            self.tree.column(f"# {col}", anchor=info[1], minwidth=0, width=info[0], stretch=info[2])
            self.tree.heading(f"# {col}", text=key)

        for rec in self.records:
            self.tree.insert('', 'end', text="1", values=self.extract(rec))

        self.tree.insert('', 'end', text="1", values=())
        self.tree.pack(expand=tk.YES, fill=tk.BOTH)
        self.pack(expand=tk.YES, fill=tk.BOTH)
        self.update()

    @staticmethod
    def extract(record):
        return [record[col] for col in ['issue', 'start', 'end', 'nbr', 'comment']]

    @property
    def selected(self):
        return self.tree.index(self.tree.focus())

    def update_record(self, record):
        item = self.tree.selection()[0]
        self.tree.item(item, values=self.extract(record))
        self.select_record()

    def add_record(self, record):
        index = self.tree.index(self.tree.focus())
        self.tree.insert('', index, text="1", values=self.extract(record))
        self.select_record()

    def delete_record(self):
        self.tree.delete(self.tree.focus())
        self.select_record()

    def select_record(self, index=-1):
        self.tree.focus(item := self.tree.get_children()[index])
        self.tree.selection_set(item)

    def bind(self, fnc):
        self.tree.bind('<<TreeviewSelect>>', fnc)


class SessionReportWnd(tk.Tk):
    def __init__(self, ses_id, sta_id, schedule):

        super().__init__()

        self.withdraw()  # To avoid window to show before fully designed

        self.session = self.scans = None
        self.records, self.ok_id, self.unsent = [], None, Unsent()
        self.can_update = settings.check_privilege(['NS', 'CC'])
        self.group = 'NS' if hasattr(settings.Signatures, "NS") else 'CC' if self.can_update else None
        try:
            self.ses_id, self.sta_id = self.validate_params(ses_id, sta_id)
            self.vcc = VCC(self.group)
            self.vcc.connect()
            self.unsent.send(self.vcc)
            self.get_session_info_from_vcc(schedule)
        except VCCError:
            self.vcc = None
            self.get_session_info_from_file(schedule)
        except ValidationError as exc:
            messagebox.showerror(exc.title, f'{str(exc)}')
            sys.exit(1)

        # Define some styles for ttk widgets
        self.style = ttk.Style(self)
        self.style.theme_use('default')
        self.style.configure('LLabel.TLabel', anchor='west', padding=(5, 5, 5, 5))
        self.style.configure('TButton', anchor='center', padding=(5, 5, 5, 5))
        self.style.configure('Options.TMenubutton', anchor='west', padding=(5, 0, 5, 0))
        self.style.configure('Scans.TCombobox', anchor='west', padding=(5, 0, 5, 0))

        # Draw main frame with all sections
        main_frame = ttk.Frame(self, padding=(5, 5, 5, 5))
        self.info = Info(main_frame, self.sta_id, self.session, self.scans)
        self.viewer = Viewer(main_frame, self.records)
        self.editor = Editor(main_frame, self.scans, 'normal' if self.can_update else 'disabled')
        self.done, self.no_problems = self.done_area(main_frame)
        self.title(f"Summary Operation for {self.sta_id.capitalize()} {self.session.code.upper()}")

        if self.can_update:
            self.editor.bind(self.record_edited)
            self.viewer.bind(self.selection_changed)
        self.viewer.select_record()

        if self.ok_id:
            self.no_problems.configure(text='Reported No Problems', state='disabled')
        elif len(self.records) > 0:
            self.no_problems.configure(text='No problems to report', state='disabled')

        main_frame.pack(expand=tk.YES, fill=tk.BOTH)
        main_frame.update()
        self.minsize(main_frame.winfo_reqwidth(), main_frame.winfo_reqheight())

        self.deiconify()  # Ok to show it

    def __del__(self):
        del self.unsent
        if self.vcc:
            self.vcc.close()

    def validate_params(self, ses_id, sta_id):
        if ses_id and sta_id:
            return ses_id, sta_id
        if self.group == 'NS':
            sta_id = sta_id if sta_id else settings.Signatures.NS[0].lower()
            if not ses_id and (log := get_ddout_log()) and (found := re.match(fr"(?P<id>[a-zA-Z0-9]{{4,12}}){sta_id}",
                                                               Path(log).stem)):
                ses_id = found['id']
        if not ses_id:
            raise ValidationError('Missing session code', 'You must input session code')
        if not sta_id:
            raise ValidationError('No station code', 'You need station code as input parameter')
        return ses_id, sta_id

    def get_session_info_from_file(self, schedule):

        if not (path := Path(schedule)).exists():
            folder = settings.Folders.schedule
            for path in [Path(folder, f'{self.ses_id}{ext}') for ext in ['.skd', '.vex']]:
                if path.exists():
                    break
            else:
                raise ValidationError('Session', f'SKD or VEX files for {self.ses_id}')
        with (VEX if path.suffix == '.vex' else SKD)(path) as sched:
            sched.read()
            self.session = Session({'code': self.ses_id, 'start': sched.start,
                                    'duration': int((sched.end - sched.start).total_seconds())})
            self.scans = Scans(self.group, self.ses_id, self.sta_id, sched)
        for rec in self.unsent.get(self.ses_id, self.sta_id):
            if rec['issue'] == 'ok':
                self.ok_id = rec['id']
            else:
                self.records.append(rec)

    def get_session_info_from_vcc(self, schedule):

        if not (rsp := self.vcc.get(f'/sessions/{self.ses_id}')):
            raise ValidationError('Invalid session code', f'Session {self.ses_id} not found')

        self.session = Session(json_decoder(rsp.json()))
        self.scans = Scans(self.group, self.ses_id, self.sta_id, schedule)
        if rsp := self.vcc.get(f'/sumops/{self.session.code}/{self.sta_id}'):
            if records := json_decoder(rsp.json()):
                if records[0].get('issue') == 'ok':
                    self.ok_id = records[0].get('id')
                    records = []
                self.records = [dict(**rec, **{'nbr': self.scans.nbr(rec['start'], rec['end'])}) for rec in records]

    def get_scans(self, schedule):
        scans = Scans(self.group, self.session, self.sta_id, schedule)
        if scans.errors:
            messagebox.showerror('Cannot read SCANS', scans.error)
            exit(1)

        return scans

    def exec(self):
        self.mainloop()

    def done_area(self, main_frame):
        frame = ttk.Frame(main_frame, padding=(0, 5, 0, 5))
        done = ttk.Button(frame, text="Done", command=self.destroy, style="TButton")
        done.pack(side='left')
        save = ttk.Button(frame, text="No problems to report", command=self.no_problems_to_report, style="TButton")
        save.pack(side='right')
        frame.pack(fill=tk.BOTH)
        frame.update()
        return done, save

    def selection_changed(self, *args):
        if (index := self.viewer.selected) < len(self.records):
            self.editor.record = self.records[index]
        else:
            self.editor.reset()

    def record_edited(self, action):
        record, index = self.editor.record, self.viewer.selected
        record['ses_id'], record['sta_id'] = self.ses_id, self.sta_id
        if action == 'Add':
            record['id'] = self.update_vcc_record(record)
            self.records.append(record)
            self.viewer.add_record(record)
            self.editor.reset()
        elif action == 'Delete':
            self.delete_vcc_record(self.records.pop(index))
            self.viewer.delete_record()
            self.editor.reset()
        elif action == 'Update':
            rec = self.records[index]
            for key, value in record.items():
                rec[key] = value
            self.update_vcc_record(rec)
            self.viewer.update_record(rec)

    def no_problems_to_report(self):
        record = {'id': self.ok_id, 'issue': 'ok', 'start': self.scans['start'],
                  'end': self.scans['end'], 'comment': 'No known issues'}
        if self.vcc is None:
            self.ok_id = self.unsent.put(self.ok_id, record, self.ses_id, self.sta_id)
        else:
            try:
                if not self.vcc.is_available:
                    self.vcc.connect()
                if rsp := self.vcc.put(f'/sumops/{self.session.code}/{self.sta_id}', data=record):
                    if index := json_decoder(rsp.json()).get('update', None):
                        self.ok_id = index
            except (VCCError, Exception) as exc:
                self.ok_id = self.unsent.put(self.ok_id, record)
        self.no_problems.configure(state='disabled')

    def update_vcc_record(self, record):
        try:
            if not self.vcc.is_available:
                self.vcc.connect()
            if rsp := self.vcc.put(f'/sumops/{self.session.code}/{self.sta_id}', data=record):
                return json_decoder(rsp.json())['update']
            self.ok_id = record['id'] if record['issue'] == 'ok' else None
        except (VCCError, Exception) as exc:
            return self.unsent.put(record.get('id', None), record, self.ses_id, self.sta_id)

    def delete_vcc_record(self, record):
        if (rec_id := record.get('id', None)) and rec_id > 0:
            try:
                if not self.vcc.is_available:
                    self.vcc.connect()
                self.vcc.delete(f'/sumops/{self.session.code}/{self.sta_id}/{rec_id}')
                return
            except VCCError:
                pass
        self.unsent.delete(rec_id, record)


def sumops(args):
    if args.report:
        SumOps(args.session)
    else:
        SessionReportWnd(args.session, args.station, args.schedule).exec()
